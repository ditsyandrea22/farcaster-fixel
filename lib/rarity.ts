/**
 * Rarity System - Single Source of Truth
 * 
 * All rarity-related logic should be imported from this file.
 * Previously duplicated across multiple files:
 * - app/api/nft-image/route.tsx
 * - app/api/nft-metadata/route.tsx
 * - lib/neynar.ts
 * - components/mini-app.tsx
 */

// ============================================================================
// Type Definitions
// ============================================================================

export type RarityTier = 'COMMON' | 'UNCOMMON' | 'SILVER' | 'GOLD' | 'PLATINUM'

export interface RarityConfig {
  name: string
  rate: number
  color: string
}

export interface TierProperties {
  name: string
  color: string
  glowIntensity: number
  borderWidth: number
  hasSparkles: boolean
  hasHalo: boolean
}

export interface RarityDetails {
  name: string
  description: string
}

// ============================================================================
// Rarity Configuration
// ============================================================================

export const RARITY_TIERS: Record<RarityTier, RarityConfig> = {
  COMMON: { 
    name: 'COMMON', 
    rate: 80, 
    color: '#6B7280',
  },
  UNCOMMON: { 
    name: 'UNCOMMON', 
    rate: 15, 
    color: '#10B981',
  },
  SILVER: { 
    name: 'SILVER', 
    rate: 4, 
    color: '#94A3B8',
  },
  GOLD: { 
    name: 'GOLD', 
    rate: 0.99, 
    color: '#F59E0B',
  },
  PLATINUM: { 
    name: 'PLATINUM', 
    rate: 0.01, 
    color: '#E5E7EB',
  },
} as const

export const MAX_SUPPLY = 20000

// ============================================================================
// Rarity Details for NFT Metadata
// ============================================================================

export const RARITY_DETAILS: Record<RarityTier, RarityDetails> = {
  COMMON: {
    name: 'Common',
    description: 'A unique pixel pattern generated by AI. Every Common NFT is one of a kind!',
  },
  UNCOMMON: {
    name: 'Uncommon',
    description: 'A rarer pixel pattern with enhanced color variation. Uncommon luck!',
  },
  SILVER: {
    name: 'Silver',
    description: 'A shimmering silver pixel pattern. The AI blessed you with good fortune!',
  },
  GOLD: {
    name: 'Gold',
    description: 'Majestic golden pixel pattern! Royal fortune smiles upon you!',
  },
  PLATINUM: {
    name: 'Platinum',
    description: 'Legendary platinum destiny! The universe has chosen you!',
  },
}

// ============================================================================
// Rarity Distribution Constants (Off-chain Reference)
// ============================================================================

export const RARITY_DISTRIBUTION = {
  COMMON: { min: 1, max: 800000, percentage: 80 },
  UNCOMMON: { min: 800001, max: 950000, percentage: 15 },
  SILVER: { min: 950001, max: 990000, percentage: 4 },
  GOLD: { min: 990001, max: 999900, percentage: 0.99 },
  PLATINUM: { min: 999901, max: 1000000, percentage: 0.01 },
} as const

// ============================================================================
// Mulberry32 PRNG - High Quality Pseudo Random Number Generator
// ============================================================================

/**
 * Mulberry32 - high quality PRNG for better distribution
 * @param seed - Initial seed value
 * @returns Function that generates random numbers 0-1
 */
function mulberry32(seed: number): () => number {
  return function() {
    let t = seed += 0x6D2B79F5
    t = Math.imul(t ^ t >>> 15, t | 1)
    t ^= t + Math.imul(t ^ t >>> 7, t | 61)
    return ((t ^ t >>> 14) >>> 0) / 4294967296
  }
}

// ============================================================================
// Hash Functions
// ============================================================================

/**
 * Hash FID to number for seeding
 * @param fid - FarCaster ID as string
 * @returns Hash value
 */
export function hashFid(fid: string): number {
  const fidNum = parseInt(fid, 10) || 0
  return fidNum
}

/**
 * Hash wallet address to number for seeding
 * @param address - Ethereum wallet address
 * @returns Hash value
 */
export function hashAddress(address: string): number {
  let hash = 0
  for (let i = 0; i < address.length; i++) {
    const char = address.charCodeAt(i)
    hash = ((hash << 5) - hash) + char
    hash = hash & hash
  }
  return Math.abs(hash)
}

/**
 * Generate truly random seed using Web Crypto API
 * @returns Random seed 0-999999
 */
export function generateRandomSeed(): number {
  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
    const array = new BigUint64Array(1)
    crypto.getRandomValues(array as unknown as Uint8Array)
    return Number(array[0] % BigInt(1000000))
  }
  return Math.floor(Math.random() * 1000000)
}

// ============================================================================
// Rarity Determination
// ============================================================================

/**
 * Determine rarity tier based on seed using Mulberry32 PRNG
 * @param seed - Random seed
 * @returns Rarity tier
 */
export function determineRarity(seed: number): RarityTier {
  // Use Mulberry32 for better random distribution
  const random = mulberry32(seed)()
  const rand = random * 100
  
  let cumulative = 0
  const rates: { tier: RarityTier; rate: number }[] = [
    { tier: 'COMMON', rate: RARITY_TIERS.COMMON.rate },
    { tier: 'UNCOMMON', rate: RARITY_TIERS.UNCOMMON.rate },
    { tier: 'SILVER', rate: RARITY_TIERS.SILVER.rate },
    { tier: 'GOLD', rate: RARITY_TIERS.GOLD.rate },
    { tier: 'PLATINUM', rate: RARITY_TIERS.PLATINUM.rate },
  ]
  
  for (const { tier, rate } of rates) {
    cumulative += rate
    if (rand <= cumulative) {
      return tier
    }
  }
  return 'COMMON'
}

/**
 * Determine rarity from FID (convenience function)
 * @param fid - FarCaster ID
 * @returns Rarity tier
 */
export function determineRarityFromFid(fid: string): RarityTier {
  return determineRarity(hashFid(fid))
}

/**
 * Determine rarity from wallet address (convenience function)
 * @param address - Ethereum wallet address
 * @returns Rarity tier
 */
export function determineRarityFromAddress(address: string): RarityTier {
  return determineRarity(hashAddress(address))
}

// ============================================================================
// Tier Properties for UI Rendering
// ============================================================================

/**
 * Get tier display properties for NFT image generation
 * @param rarity - Rarity tier
 * @returns Tier properties
 */
export function getTierProperties(rarity: RarityTier): TierProperties {
  const tier = RARITY_TIERS[rarity]
  return {
    name: tier.name,
    color: tier.color,
    glowIntensity: rarity === 'PLATINUM' ? 0.8 : rarity === 'GOLD' ? 0.6 : rarity === 'SILVER' ? 0.4 : 0.2,
    borderWidth: rarity === 'PLATINUM' ? 4 : rarity === 'GOLD' ? 3 : rarity === 'SILVER' ? 2 : 1,
    hasSparkles: rarity === 'PLATINUM' || rarity === 'GOLD' || rarity === 'SILVER',
    hasHalo: rarity === 'PLATINUM',
  }
}

// ============================================================================
// Color Generation
// ============================================================================

/**
 * Generate colors based on seed and rarity
 * @param seed - Random seed
 * @param rarity - Rarity tier
 * @returns Color configuration
 */
export function generateColors(seed: number, rarity: RarityTier): {
  primary: string
  secondary: string
  accent: string
  bgGradient: string
} {
  const random = mulberry32(seed)
  const rarityBoost = rarity === 'PLATINUM' ? 40 : rarity === 'GOLD' ? 30 : rarity === 'SILVER' ? 20 : 0
  
  const hue1 = (seed * 137.5) % 360
  const hue2 = (hue1 + 180) % 360
  const sat = 60 + ((seed % 20) * 2) + rarityBoost
  const light = 55 + (rarityBoost / 2)
  
  // Special colors for higher rarities
  if (rarity === 'PLATINUM') {
    return {
      primary: 'linear-gradient(135deg, #E5E7EB, #9CA3AF)',
      secondary: 'linear-gradient(135deg, #D1D5DB, #6B7280)',
      accent: '#FFFFFF',
      bgGradient: 'linear-gradient(135deg, #F9FAFB 0%, #E5E7EB 50%, #D1D5DB 100%)',
    }
  }
  
  if (rarity === 'GOLD') {
    return {
      primary: `linear-gradient(135deg, #F59E0B, #D97706)`,
      secondary: `linear-gradient(135deg, #FCD34D, #F59E0B)`,
      accent: '#FEF3C7',
      bgGradient: 'linear-gradient(135deg, #FFFBEB 0%, #FEF3C7 50%, #FDE68A 100%)',
    }
  }
  
  return {
    primary: `hsl(${hue1}, ${sat}%, ${light}%)`,
    secondary: `hsl(${hue2}, ${sat}%, ${light - 10}%)`,
    accent: `hsl(${(hue1 + 60) % 360}, ${Math.min(sat + 20, 100)}%, ${Math.min(light + 15, 80)}%)`,
    bgGradient: `linear-gradient(135deg, hsl(${hue1}, ${sat}%, 98%) 0%, hsl(${hue2}, ${sat}%, 96%) 100%)`,
  }
}

// ============================================================================
// Pattern Generation
// ============================================================================

/**
 * Generate unique pixel pattern based on seed and rarity
 * @param seed - Random seed
 * @param rarity - Rarity tier
 * @returns 2D boolean array representing pixel pattern
 */
export function generatePixelPattern(seed: number, rarity: RarityTier): boolean[][] {
  const gridSize = rarity === 'PLATINUM' ? 16 : rarity === 'GOLD' ? 14 : 12
  const pattern: boolean[][] = Array(gridSize)
    .fill(null)
    .map(() => Array(gridSize).fill(false))
  
  const random = mulberry32(seed)
  const densityMultiplier = rarity === 'PLATINUM' ? 1.5 : rarity === 'GOLD' ? 1.3 : rarity === 'SILVER' ? 1.2 : 1
  
  for (let i = 0; i < gridSize; i++) {
    for (let j = 0; j < gridSize; j++) {
      const hash = (seed * (i + 1) * (j + 1) * 73856093) ^ ((seed >> 16) * 19349663)
      const threshold = 0.5 / densityMultiplier
      pattern[i][j] = (hash & 1) === 1 && random() > threshold
    }
  }
  
  return pattern
}

// ============================================================================
// Serial Number Generation
// ============================================================================

/**
 * Generate NFT serial number based on seed
 * @param seed - Random seed
 * @returns Serial number string
 */
export function generateSerialNumber(seed: number): string {
  const num = (seed % MAX_SUPPLY) + 1
  return `#${num.toString().padStart(5, '0')}/${MAX_SUPPLY}`
}

// ============================================================================
// NFT Attributes for Metadata
// ============================================================================

/**
 * Get tier color for NFT metadata
 * @param rarity - Rarity tier
 * @returns Hex color string
 */
export function getTierColor(rarity: RarityTier): string {
  return RARITY_TIERS[rarity].color
}

/**
 * Generate NFT attributes for metadata
 * @param rarity - Rarity tier
 * @param seed - Random seed
 * @returns Array of attribute objects
 */
export function getAttributes(rarity: RarityTier, seed: number) {
  return [
    {
      trait_type: 'Rarity',
      value: RARITY_DETAILS[rarity].name,
      display_type: 'string',
    },
    {
      trait_type: 'Rarity Tier',
      value: rarity,
      display_type: 'string',
    },
    {
      trait_type: 'Color Theme',
      value: getTierColor(rarity),
      display_type: 'color_hex',
    },
    {
      trait_type: 'Seed',
      value: seed,
      display_type: 'number',
      max_value: 9999999,
    },
    {
      trait_type: 'Tier Probability',
      value: `${RARITY_TIERS[rarity].rate}%`,
      display_type: 'string',
    },
    {
      trait_type: 'Generated At',
      value: new Date().toISOString(),
      display_type: 'date',
    },
  ]
}

// ============================================================================
// Fortune Messages (for UI)
// ============================================================================

const FORTUNE_MESSAGES: Record<RarityTier, string[]> = {
  PLATINUM: [
    "üåü LEGENDARY! Your luck is cosmic!",
    "‚ú® The universe has chosen you!",
    "üíé Pure platinum destiny awaits!",
  ],
  GOLD: [
    "üëë Royal fortune smiles upon you!",
    "üåÖ Golden rays of opportunity!",
    "‚ú® Majestic destiny unfolds!",
  ],
  SILVER: [
    "‚≠ê Shimmering silver path ahead!",
    "üåô Gentle luck guides your way!",
    "‚ú® Bright prospects incoming!",
  ],
  UNCOMMON: [
    "üçÄ Good fortune favors you!",
    "üåø A lucky breeze blows your way!",
    "‚ú® Opportunities await!",
  ],
  COMMON: [
    "ü§ù Every journey begins somewhere!",
    "üéØ Your unique path awaits!",
    "‚ú® Your NFT, uniquely yours!",
  ],
}

/**
 * Get random fortune message based on rarity
 * @param rarity - Rarity tier
 * @returns Fortune message
 */
export function getFortuneMessage(rarity: RarityTier): string {
  const messages = FORTUNE_MESSAGES[rarity]
  return messages[Math.floor(Math.random() * messages.length)]
}
