import { NextRequest, NextResponse } from 'next/server'
import { getRateLimitResult, defaultConfig } from '@/lib/rate-limit'

export const runtime = 'nodejs'

const BASE_URL = process.env.NEXT_PUBLIC_BASE_URL || 'https://farcaster-fixel.vercel.app'

// Rarity tiers (must match nft-image/route.tsx)
const RARITY_TIERS = {
  COMMON: { name: 'COMMON', rate: 80, color: '#6B7280' },
  UNCOMMON: { name: 'UNCOMMON', rate: 15, color: '#10B981' },
  SILVER: { name: 'SILVER', rate: 4, color: '#94A3B8' },
  GOLD: { name: 'GOLD', rate: 0.99, color: '#F59E0B' },
  PLATINUM: { name: 'PLATINUM', rate: 0.01, color: '#E5E7EB' },
} as const

type RarityTier = keyof typeof RARITY_TIERS

// Rarity display names and descriptions
const RARITY_DETAILS: Record<RarityTier, { name: string; description: string }> = {
  COMMON: {
    name: 'Common',
    description: 'A unique pixel pattern generated by AI. Every Common NFT is one of a kind!',
  },
  UNCOMMON: {
    name: 'Uncommon',
    description: 'A rarer pixel pattern with enhanced color variation. Uncommon luck!',
  },
  SILVER: {
    name: 'Silver',
    description: 'A shimmering silver pixel pattern. The AI blessed you with good fortune!',
  },
  GOLD: {
    name: 'Gold',
    description: 'Majestic golden pixel pattern! Royal fortune smiles upon you!',
  },
  PLATINUM: {
    name: 'Platinum',
    description: 'Legendary platinum destiny! The universe has chosen you!',
  },
}

// Cryptographically secure random number generator (0-1)
function cryptoRandom(): number {
  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
    const array = new Uint32Array(1)
    crypto.getRandomValues(array)
    return array[0] / (0xFFFFFFFF + 1)
  }
  // Fallback for Node.js
  return Math.random()
}

// Seeded random number generator for deterministic results (must match nft-image/route.tsx)
function seededRandom(seed: number): number {
  const x = Math.sin(seed) * 10000
  return x - Math.floor(x)
}

// Enhanced seeded random using Mulberry32 for better distribution
function mulberry32(seed: number): () => number {
  return function() {
    let t = seed += 0x6D2B79F5
    t = Math.imul(t ^ t >>> 15, t | 1)
    t ^= t + Math.imul(t ^ t >>> 7, t | 61)
    return ((t ^ t >>> 14) >>> 0) / 4294967296
  }
}

// Determine rarity from seed using improved algorithm
function determineRarity(seed: number): RarityTier {
  // Use Mulberry32 for better random distribution
  const random = mulberry32(seed)()
  const rand = random * 100
  
  let cumulative = 0
  const rates = [
    { tier: 'COMMON' as RarityTier, rate: RARITY_TIERS.COMMON.rate },
    { tier: 'UNCOMMON' as RarityTier, rate: RARITY_TIERS.UNCOMMON.rate },
    { tier: 'SILVER' as RarityTier, rate: RARITY_TIERS.SILVER.rate },
    { tier: 'GOLD' as RarityTier, rate: RARITY_TIERS.GOLD.rate },
    { tier: 'PLATINUM' as RarityTier, rate: RARITY_TIERS.PLATINUM.rate },
  ]
  
  for (const { tier, rate } of rates) {
    cumulative += rate
    if (rand <= cumulative) {
      return tier
    }
  }
  return 'COMMON'
}

// Generate truly random seed using Web Crypto API
function generateRandomSeed(): number {
  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
    const array = new BigUint64Array(1)
    crypto.getRandomValues(array as unknown as Uint8Array)
    return Number(array[0] % BigInt(1000000))
  }
  // Fallback for Node.js
  return Math.floor(Math.random() * 1000000)
}

// Hash FID to number for seeding
function hashFid(fid: string): number {
  const fidNum = parseInt(fid, 10) || 0
  // Combine with random seed for uniqueness
  return fidNum ^ generateRandomSeed()
}

// Hash wallet address to number for seeding
function hashAddress(address: string): number {
  let hash = 0
  for (let i = 0; i < address.length; i++) {
    const char = address.charCodeAt(i)
    hash = ((hash << 5) - hash) + char
    hash = hash & hash
  }
  // Combine with random seed for uniqueness
  return Math.abs(hash) ^ generateRandomSeed()
}

// Get tier color
function getTierColor(rarity: RarityTier): string {
  return RARITY_TIERS[rarity].color
}

// Generate NFT attributes
function getAttributes(rarity: RarityTier, seed: number) {
  return [
    {
      trait_type: 'Rarity',
      value: RARITY_DETAILS[rarity].name,
      display_type: 'string',
    },
    {
      trait_type: 'Rarity Tier',
      value: rarity,
      display_type: 'string',
    },
    {
      trait_type: 'Color Theme',
      value: getTierColor(rarity),
      display_type: 'color_hex',
    },
    {
      trait_type: 'Seed',
      value: seed,
      display_type: 'number',
      max_value: 9999999,
    },
    {
      trait_type: 'Tier Probability',
      value: `${RARITY_TIERS[rarity].rate}%`,
      display_type: 'string',
    },
    {
      trait_type: 'Generated At',
      value: new Date().toISOString(),
      display_type: 'date',
    },
  ]
}

export async function GET(request: NextRequest) {
  try {
    // Get client IP for rate limiting
    const ip = request.headers.get('x-forwarded-for') || 
               request.headers.get('x-real-ip') || 
               'unknown'
    
    const rateLimit = getRateLimitResult(ip)
    
    if (!rateLimit.allowed) {
      return NextResponse.json(
        { error: 'Too many requests. Please try again later.' },
        { 
          status: 429,
          headers: {
            'Retry-After': Math.ceil((rateLimit.resetTime - Date.now()) / 1000).toString(),
            'X-RateLimit-Limit': defaultConfig.maxRequests.toString(),
            'X-RateLimit-Remaining': '0',
          }
        }
      )
    }

    const fid = request.nextUrl.searchParams.get('fid')
    const address = request.nextUrl.searchParams.get('address')
    const tokenId = request.nextUrl.searchParams.get('tokenId')
    const randomize = request.nextUrl.searchParams.get('random') === 'true'

    if (!fid && !address && !tokenId) {
      return NextResponse.json({ error: 'FID, wallet address, or token ID is required' }, { status: 400 })
    }

    // Determine the seed for this NFT
    let seed: number
    let ownerAddress: string | null = null
    
    if (tokenId) {
      // If tokenId is provided, use it as the seed (deterministic)
      seed = parseInt(tokenId, 10) || generateRandomSeed()
    } else if (randomize) {
      // Truly random seed for each request
      seed = generateRandomSeed()
      ownerAddress = address || null
    } else {
      // Deterministic seed based on FID or address
      seed = fid ? hashFid(fid) : hashAddress(address!)
      ownerAddress = address || null
    }

    // Determine rarity based on seed
    const rarity = determineRarity(seed)
    const rarityDetails = RARITY_DETAILS[rarity]
    
    // Generate image URL
    const imageUrl = tokenId 
      ? `${BASE_URL}/api/nft-image?tokenId=${tokenId}`
      : (fid 
          ? `${BASE_URL}/api/nft-image?fid=${fid}`
          : `${BASE_URL}/api/nft-image?address=${address}`
        )

    // Generate external URL for the NFT
    const externalUrl = tokenId
      ? `${BASE_URL}/nft/${tokenId}`
      : `${BASE_URL}?fid=${fid || ''}&address=${address || ''}`

    // Build ERC721 compliant metadata
    const metadata = {
      name: `PixelCaster AI #${tokenId || (seed % 20000 + 1).toString().padStart(5, '0')}`,
      description: rarityDetails.description,
      image: imageUrl,
      image_url: imageUrl,
      external_url: externalUrl,
      externalUrl: externalUrl,
      animation_url: null,
      youtube_url: null,
      background_color: getTierColor(rarity).replace('#', ''),
      background_color_hex: getTierColor(rarity).replace('#', ''),
      traits: getAttributes(rarity, seed),
      attributes: getAttributes(rarity, seed),
      collection: {
        name: 'PixelCaster AI',
        family: 'PixelCaster AI Collection',
        display_name: 'PixelCaster AI NFT',
      },
      dna: seed.toString(16),
      date: Date.now(),
      generated_at: new Date().toISOString(),
      compiler: 'PixelCaster AI Generator v1.0 (CSPRNG)',
      randomness: {
        algorithm: 'Mulberry32 + Web Crypto API',
        seed: seed,
        is_deterministic: !randomize,
      },
      created_by: ownerAddress || 'unknown',
    }

    // Add CORS headers for external access
    const response = NextResponse.json(metadata, {
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Cache-Control': 'public, max-age=3600, s-maxage=86400',
      },
    })

    return response
  } catch (error) {
    console.error('Error generating NFT metadata:', error)
    return NextResponse.json(
      { error: 'Failed to generate metadata' },
      { status: 500 }
    )
  }
}

// Handle preflight requests
export async function OPTIONS() {
  return NextResponse.json({}, {
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type',
    },
  })
}
